const t={WIDTH:64,HEIGHT:32,DEPTH:16},e={BACKGROUND:0},s={WIDTH:32,HEIGHT:32,SPEED:.2,CHUNK_LOAD_DISTANCE:2};class i{constructor(){this.chunks=new Map,this.chunkSize=8,this.chunkStates=new Map,console.log("[World] Initialized with chunk size",this.chunkSize)}updateChunks(t,e){const i=Math.floor(t/this.chunkSize),h=Math.floor(e/this.chunkSize);console.log(`[World] Updating chunks around player at chunk [${i},${h}]`),this.unloadDistantChunks(t,e);const n=new Set;for(let t=0;t<=s.CHUNK_LOAD_DISTANCE;t++)for(let e=-t;e<=t;e++)for(let s=-t;s<=t;s++)if(Math.max(Math.abs(e),Math.abs(s))===t){const t=i+e,o=h+s,r=`${t},${o}`;this.chunks.has(r)?"dormant"===this.chunkStates.get(r)&&(console.log(`[World] Reactivating dormant chunk at [${t},${o}]`),this.chunkStates.set(r,"loaded"),n.add(r)):(console.log(`[World] Generating new chunk at [${t},${o}]`),this.generateChunk(t,o),n.add(r))}Array.from(this.chunks.entries()).filter(([t])=>"loaded"===this.chunkStates.get(t)).map(([t])=>t)}generateChunk(t,e){const s=`${t},${e}`;if("dormant"===this.chunkStates.get(s))return this.chunkStates.set(s,"loaded"),console.log(`[World] Reactivated dormant chunk ${s}`),this.chunks.get(s);console.log(`[World] Generating fresh chunk ${s}`);const i={blocks:this.generateTerrain(t,e),needsUpdate:!0};return this.chunks.set(s,i),this.chunkStates.set(s,"loaded"),i}generateTerrain(t,e){return Array(this.chunkSize).fill().map(()=>Array(this.chunkSize).fill().map(()=>[null,{type:"grass"}]))}unloadDistantChunks(t,e){const i=Math.floor(t/this.chunkSize),h=Math.floor(e/this.chunkSize);let n=0,o=0;this.chunks.forEach((t,e)=>{const[r,a]=e.split(",").map(Number),c=Math.max(Math.abs(r-i),Math.abs(a-h));c>s.CHUNK_LOAD_DISTANCE&&(c>s.CHUNK_LOAD_DISTANCE+1?(console.log(`[World] Unloading distant chunk [${r},${a}] (distance ${c})`),this.chunks.delete(e),this.chunkStates.delete(e),n++):"loaded"===this.chunkStates.get(e)&&(console.log(`[World] Marking chunk [${r},${a}] as dormant (distance ${c})`),this.chunkStates.set(e,"dormant"),o++))}),(n>0||o>0)&&console.log(`[World] Unloaded ${n} chunks, set ${o} to dormant`)}getNeighbors(t,e,s=0){return t=Math.floor(t),e=Math.floor(e),s=Math.floor(s),{north:this.getBlock(t,e-1,s),south:this.getBlock(t,e+1,s),east:this.getBlock(t+1,e,s),west:this.getBlock(t-1,e,s),top:this.getBlock(t,e,s+1),bottom:this.getBlock(t,e,s-1)}}getChunkId(t,e){return`${Math.floor(t/this.chunkSize)},${Math.floor(e/this.chunkSize)}`}getChunk(t,e){const s=this.getChunkId(t,e);return this.chunks.has(s)||this.chunks.set(s,{blocks:Array(this.chunkSize).fill().map(()=>Array(this.chunkSize).fill().map(()=>Array(1).fill(null))),needsUpdate:!0}),this.chunks.get(s)}getBlock(t,e,s=0){if("number"!=typeof t||"number"!=typeof e)return null;const i=this.getChunk(t,e),h=(Math.floor(t)%this.chunkSize+this.chunkSize)%this.chunkSize,n=(Math.floor(e)%this.chunkSize+this.chunkSize)%this.chunkSize;return!i||!i.blocks[h]||!i.blocks[h][n]||s<0||s>=i.blocks[h][n].length?null:i.blocks[h][n][s]}setBlock(t,e,s,i){const h=this.getChunk(t,e),n=(t%this.chunkSize+this.chunkSize)%this.chunkSize,o=(e%this.chunkSize+this.chunkSize)%this.chunkSize;for(;s>=h.blocks[n][o].length;)h.blocks[n][o].push(null);return h.blocks[n][o][s]=i,h.needsUpdate=!0,!0}getVisibleBlocks(){const t=[];for(const[e,s]of this.chunks)for(let i=0;i<this.chunkSize;i++)for(let h=0;h<this.chunkSize;h++)for(let n=0;n<s.blocks[i][h].length;n++){const o=s.blocks[i][h][n];if(o){const s=e.split(","),r=parseInt(s[0])*this.chunkSize+i,a=parseInt(s[1])*this.chunkSize+h;t.push({x:r,z:a,y:n,block:o})}}return t}}class h{constructor(t,e,s){this.app=t,this.world=e,this.game=s,this.textures={grassTop:PIXI.Texture.from("assets/grass-top.png"),grassSouth:PIXI.Texture.from("assets/grass-south.png"),grassEast:PIXI.Texture.from("assets/grass-east.png")},Object.values(this.textures).forEach(t=>{t.baseTexture.scaleMode=PIXI.SCALE_MODES.NEAREST}),this.chunkContainers=new Map}async loadTextures(){return await Promise.all([this.textures.grassTop.baseTexture.onLoaded,this.textures.grassSouth.baseTexture.onLoaded,this.textures.grassEast.baseTexture.onLoaded]),!0}render(){const t=this.game.player.sprite;this.app.stage.removeChildren(),t&&this.app.stage.addChild(t);Array.from(this.world.chunks.entries()).filter(([t])=>"loaded"===this.world.chunkStates.get(t)).forEach(([t,e])=>{let s=this.chunkContainers.get(t);s&&!e.needsUpdate&&this.chunkContainers.has(t)||(s=this.createChunkContainer(t,e),this.chunkContainers.set(t,s),e.needsUpdate=!1,this.chunkContainers.set(t,s)),this.app.stage.addChild(s)}),t&&this.app.stage.addChild(t)}createChunkContainer(t,e){const s=new PIXI.Container,[i,h]=t.split(",").map(Number),n=i*this.world.chunkSize,o=h*this.world.chunkSize;for(let t=0;t<this.world.chunkSize;t++)for(let i=0;i<this.world.chunkSize;i++)for(let h=0;h<e.blocks[t][i].length;h++){const r=e.blocks[t][i][h];if(r){const e=this.createTile(n+t,o+i,h,r);s.addChild(e)}}return s}createTile(e,s,i,h){const n=new PIXI.Container,o=(e-s)*t.WIDTH/2,r=(e+s)*t.HEIGHT/2;return n.position.set(o,r-i*t.DEPTH),this.drawBlock(n,h,e,s,i),n}drawBlock(e,s,i,h,n){const o=t.WIDTH/2,r=this.world.getNeighbors(i,h,n),a=new PIXI.Sprite(this.textures.grassTop);if(a.anchor.set(.5,.5),a.position.set(o,0),e.addChild(a),!r.south){const t=new PIXI.Sprite(this.textures.grassSouth);t.anchor.set(0,0),t.position.set(0,0),e.addChild(t)}if(!r.east){const s=new PIXI.Sprite(this.textures.grassEast);s.anchor.set(1,0),s.position.set(t.WIDTH,0),e.addChild(s)}}}class n{constructor(t){this.game=t,this.x=0,this.z=0,this.y=1,this.sprite=PIXI.Sprite.from("assets/player.png"),this.sprite.texture.baseTexture.scaleMode=PIXI.SCALE_MODES.NEAREST,this.sprite.anchor.set(.5,.9),this.sprite.width=s.WIDTH,this.sprite.height=s.HEIGHT,this.movement={up:!1,down:!1,left:!1,right:!1},this.setupControls(),this.updateSpritePosition()}setupControls(){window.addEventListener("keydown",t=>this.handleKeyDown(t)),window.addEventListener("keyup",t=>this.handleKeyUp(t))}handleKeyDown(t){switch(t.key){case"w":case"ArrowUp":this.movement.up=!0;break;case"s":case"ArrowDown":this.movement.down=!0;break;case"a":case"ArrowLeft":this.movement.left=!0;break;case"d":case"ArrowRight":this.movement.right=!0}}handleKeyUp(t){switch(t.key){case"w":case"ArrowUp":this.movement.up=!1;break;case"s":case"ArrowDown":this.movement.down=!1;break;case"a":case"ArrowLeft":this.movement.left=!1;break;case"d":case"ArrowRight":this.movement.right=!1}}update(t){const e=s.SPEED*t;let i=0,h=0;this.movement.up&&(h-=e),this.movement.down&&(h+=e),this.movement.left&&(i-=e),this.movement.right&&(i+=e),0!==i&&0!==h&&(i*=.7071,h*=.7071),this.x+=i,this.z+=h,this.updateSpritePosition()}updateSpritePosition(){const e=(this.x-this.z)*t.WIDTH/2,s=(this.x+this.z)*t.HEIGHT/2;this.sprite.position.set(e,s-this.y*t.DEPTH)}}class o{constructor(){this.app=new PIXI.Application({view:document.getElementById("game-canvas"),resizeTo:window,backgroundColor:e.BACKGROUND,antialias:!1,resolution:1}),PIXI.settings.SCALE_MODE=PIXI.SCALE_MODES.NEAREST,this.world=new i,this.renderer=new h(this.app,this.world,this),this.initGame()}async initGame(){await this.renderer.loadTextures(),this.player=new n(this),this.world.updateChunks(this.player.x,this.player.z),this.setup(),this.gameLoop()}setup(){this.renderer.render(),window.addEventListener("resize",()=>this.renderer.render()),this.app.stage.addChild(this.player.sprite),this.centerOnPlayer()}gameLoop(){this.app.ticker.add(t=>{this.player.update(t),this.world.updateChunks(this.player.x,this.player.z),this.centerOnPlayer()})}centerOnPlayer(){const e=(this.player.x-this.player.z)*t.WIDTH/2,s=(this.player.x+this.player.z)*t.HEIGHT/2;this.app.stage.position.set(this.app.screen.width/2-e,this.app.screen.height/2-s-t.HEIGHT)}}document.addEventListener("DOMContentLoaded",()=>{const t=new o;window.game=t});
